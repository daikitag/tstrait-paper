%%
%% Copyright 2022 OXFORD UNIVERSITY PRESS
%%
%% This file is part of the 'oup-authoring-template Bundle'.
%% ---------------------------------------------
%%
%% It may be distributed under the conditions of the LaTeX Project Public
%% License, either version 1.2 of this license or (at your option) any
%% later version.  The latest version of this license is in
%%    http://www.latex-project.org/lppl.txt
%% and version 1.2 or later is part of all distributions of LaTeX
%% version 1999/12/01 or later.
%%
%% The list of all files belonging to the 'oup-authoring-template Bundle' is
%% given in the file `manifest.txt'.
%%
%% Template article for OXFORD UNIVERSITY PRESS's document class `oup-authoring-template'
%% with bibliographic references
%%

%%%CONTEMPORARY%%%
%\documentclass[unnumsec,webpdf,contemporary,large]{oup-authoring-template}%
%\documentclass[unnumsec,webpdf,contemporary,large,namedate]{oup-authoring-template}% uncomment this line for author year citations and comment the above
%\documentclass[unnumsec,webpdf,contemporary,medium]{oup-authoring-template}
%\documentclass[unnumsec,webpdf,contemporary,small]{oup-authoring-template}

%%%MODERN%%%
%\documentclass[unnumsec,webpdf,modern,large]{oup-authoring-template}
\documentclass[unnumsec,webpdf,modern,large,namedate]{oup-authoring-template}% uncomment this line for author year citations and comment the above
%\documentclass[unnumsec,webpdf,modern,medium]{oup-authoring-template}
%\documentclass[unnumsec,webpdf,modern,small]{oup-authoring-template}

%%%TRADITIONAL%%%
%\documentclass[unnumsec,webpdf,traditional,large]{oup-authoring-template}
%\documentclass[unnumsec,webpdf,traditional,large,namedate]{oup-authoring-template}% uncomment this line for author year citations and comment the above
%\documentclass[unnumsec,namedate,webpdf,traditional,medium]{oup-authoring-template}
%\documentclass[namedate,webpdf,traditional,small]{oup-authoring-template}

%\onecolumn % for one column layouts

%\usepackage{showframe}
\usepackage{fontenc}


\usepackage{graphicx}

% line numbers
% \usepackage[mathlines, switch]{lineno}
% \usepackage[right]{lineno}

\begin{document}

% \journaltitle{Bioinformatics}
\journaltitle{Preprint}
% \DOI{DOI HERE}
\copyrightyear{2023}
% \pubyear{2019}
% \access{Advance Access Publication Date: Day Month Year}
\appnotes{Paper}

\firstpage{1}

%\subtitle{Subject Section}

\title[tstrait]{tstrait: a quantitative trait simulator for ancestral recombination graphs}

\author[1,2,$\ast$]{Daiki Tagami\ORCID{0000-0002-0923-1070}}
\author[2]{Gertjan Bisschop\ORCID{0000-0001-8327-0142}}
\author[2]{Jerome Kelleher\ORCID{0000-0002-7894-5253}}

\authormark{D.Tagami et al.}

\address[1]{\orgdiv{Department of Statistics}, \orgname{University of Oxford},
\orgaddress{\street{24-29 St Giles'}, \postcode{Oxford OX1 3LB},
\country{United Kingdom}}}
\address[2]{\orgdiv{Big Data Institute,
Li Ka Shing Centre for Health Information and Discovery},
\orgname{University of Oxford}, \orgaddress{\street{Old Road Campus},
\postcode{Oxford OX3 7LF}, \country{United Kingdom}}}

\corresp[$\ast$]{Corresponding author.
\href{email:daiki.tagami@hertford.ox.ac.uk}{daiki.tagami@hertford.ox.ac.uk}}

\received{Date}{0}{Year}
\revised{Date}{0}{Year}
\accepted{Date}{0}{Year}

\abstract{
\textbf{Summary:}
Ancestral recombination graphs (ARGs) encode the ensemble of correlated
genealogical trees arising from recombination in a compact and efficient
structure, and are of fundamental importance in population and statistical
genetics. Recent breakthroughs have made it possible to simulate and
infer ARGs at the population scale, and there is now intense interest
in applying ARG-based methods across a broad range of applications.
Genome-wide association studies (GWAS) are one of the most important
application areas, with ARG-based methods already providing substantial
improvements over the state-of-the-art. The ability to efficiently
simulate quantitative traits is critical to developing
and evaluating new GWAS methods, but existing simulators do not scale
to modern datasets and cannot be directly applied to ARGs.
We present the \texttt{tstrait} package,
an open-source Python library to simulate
quantitative traits on ARGs, and show how this user-friendly software
can be easily applied to vast, population-scale datasets.
\\\textbf{Availability and Implementation:} \texttt{tstrait} is available
for download on the Python Package Index.
Full documentation with examples and workflow
templates is available on \url{https://tskit.dev/tstrait/docs/}, and the
development version is maintained on Github
(\url{https://github.com/tskit-dev/tstrait}).\\ \textbf{Contact:}
\href{daiki.tagami@hertford.ox.ac.uk}{daiki.tagami@hertford.ox.ac.uk}\\
}

%\abstract{Abstracts must be able to stand alone and so cannot contain %citations to
%the paper's references, equations, etc. An abstract must consist of a single
%paragraph and be concise. Because of online formatting, abstracts must appear
%as plain as possible.}
\keywords{Ancestral Recombination Graph, ARG, GWAS, quantitative traits,
simulation}

\maketitle

\section{Introduction}

Genome-wide association studies (GWAS)
identify genetic variants that are statistically
associated with a specific trait~\citep{uffelmann2021}.
Many loci that are associated with various human diseases and
traits have been identified~\citep{locke2015,ishigaki2022,
mahajan2022,yengo2022,mathieson2023},
and GWAS results are actively being incorporated into clinical
practice~\citep{visscher2017}.
This success has led to the collection of many population-scale Biobank
datasets~\citep{tanjo2021practical}.
This dense sampling and resulting vast volumes of data, however,
are presenting significant challenges to GWAS methology.
For example, how to correctly account for population stratification
remains an open question~\citep{uffelmann2021}.

Ancestral recombination graphs (ARGs) encode the interwoven paths
of genetic inheritance arising from
% Explanation of citations: people might get offended if we don't cite
% Griffiths when first mentioning the ARG, but Hudson has just as
% much to do with the actual definition that we use in Wong 2023.
recombination~\citep{hudson1983properties,griffiths1997ancestral,wong2023general},
and recent
breakthroughs in inference have opened many new possibilities for their
practical application~\citep{lewanski2023era}.
Building on these recent developments, substantial progress has been made
on statistical genetics applications.
For example,  ARG-based methods
can detect more ultra rare variants than conventional association testing
methods~\citep{zhang2023};
have better power to detect causal loci in
quantitative-trait locus mapping~\citep{link2023tree};
and can provide a sparse and efficient model of linkage disequilibirium
in GWAS and downstream applications~\citep{nowbandegani2023extremely}.

Simulation is a critical component of GWAS method development, and
generally consists of two steps: (1) generate a synthetic genetic
variation dataset; and (2) simulate some quantitative traits
based on this dataset.
(The two steps may sometimes be combined
in a single simulation, or we may use real data instead of simulations in
step (2), but the basic principles are still the same.)
The combined genetic variation and
simulated quantitative traits then represent the ``truth'' against
which association testing methods can be evaluated.
The first step, of generating realistic, large-scale genetic variation
datasets, is a well-studied problem with a mature and robust supporting
software ecosystem. ARG-based methods~\citep{kelleher2016efficient,
kelleher2018efficient,haller2018tree,adrion2020,baumdicker2022efficient,anderson2023}
have been instrumental in making population genetic simulations
of the scale and realism
required to model modern GWAS cohorts~\cite[e.g.][]{martin2017,zaidi2020}.
These simulation methods are all based on the ``succinct tree
sequence'' ARG encoding~\citep{ralph2020,wong2023general},
using the open-source \texttt{tskit} library.

An important property of the succinct tree sequence ARG encoding
used by these population genetic simulators is that it allows us to
store enormous genetic variation datasets compactly. Instead of
storing the genetic sequence variation in the conventional
matrix-based form~\citep[e.g.\ VCF,][]{danecek2011},
we can store the underlying genealogical history
and mutations that ultimately \emph{result} in the observed
variation~\citep{kelleher2019}.
For example, a highly realistic simulation
of chromosome 9 for 1.4 million
French-Canadian individuals~\citep{anderson2023}
requires around 550GB of storage space in
gzip-compressed VCF ($\sim$280TB uncompressed).
The original simulation file representing
precisely the same genetic variation data, plus the
complete simulated ARG, requires only 1.36GB of space
in compressed \texttt{tszip} format. Thus,
by encoding in terms of the underlying ARG,
in this case we achieve more than 400-fold compression,
and this highly unwieldy dataset
becomes straightforward to work with (we discuss this
landmark dataset again in later sections).
Another substantial benefit of storing simulated datasets
in this ARG-based format is that many computations can
be expressed efficiently in terms of the underlying
ancestry~\citep{kelleher2016efficient,ralph2020}, without
needing to decode the actual variation data.

There are therefore sophisticated methods available for simulating
ARGs at the population scale, but there is currently no
easy way to generate quantitative traits based on such an ARG.
Existing methods to simulate quantitative traits from a given set of
genetic sequences in standard formats~\citep[e.g.][]{meyer2018,fernandes2020}
are overwhelmed by the scale of the data. For example,
just parsing the 280TB of VCF for the French-Canadian
dataset mentioned above would take many days of CPU time,
making quantitative trait simulation by this approach unfeasible.
% TODO this needs another pass. We do need to address the Martin et
% al thing up front though, I think.
In their analysis of the portability of polygenic risk
scores across populations, \citet{martin2017}
used efficient \texttt{tskit} APIs to simulate quantitative
traits for 600,000 humans directly from a simulated ARG.
While the code provided by Martin et al.\ works at this
very large scale, it is tightly coupled to the details of their study
and not designed to be reused.
Simulation code can be subtle and difficult to
debug~\citep{ragsdale2020lessons}, and there
is therefore a critical need for a well-documented and
thoroughly tested means of simulating quantitative
traits directly from an ARG.

In this paper we present \texttt{tstrait}, a new Python library that
efficiently simulates quantitative traits on an arbitrary ARG
in \texttt{tskit}~\citep{ralph2020} format.
\texttt{Tstrait} can
quickly simulate quantitative traits for population-scale datasets,
with a very low memory overhead. This approach also provides a
richer model than existing methods,
allowing us to, for example, simulate traits for
ancestral individuals as well as contemporary samples.
The \texttt{tstrait} library also integrates well with the wider
Python data-science ecosytem, allowing users to efficiently analyse
large-scale data using familiar and ergonomic tools.

\section{Results}
\begin{figure}[t]%
\centering
\includegraphics[width=240pt]{figures/tree-illustration.pdf}
\caption{Example simulation of a phenotype at a site with ancestral state A and
two mutations. In this diploid example each of the three individuals
is assocated with two nodes (i.e., the individual with ID 0 corresponds
to nodes \textsf{a} and \textsf{b}). Internal nodes in the tree are associated
with the null individual, $-1$. Here, the trait's causal allele is T
and effect size $\beta=0.05$. Each node in the tree has an associated
genetic value, and the overall genetic value for an individual is the
sum of their corresponding node values. The final phenotype
for each individual is the sum of the genetic value and
simulated environmental noise.
\label{fig:tree-illustration}}
\end{figure}

\subsection{Model}
Phenotypes are simulated in \texttt{tstrait} following standard
models, adapted to the ARG context (Fig~\ref{fig:tree-illustration}).
Each trait is associated with one or more causal sites (position
on the genome), and at each causal site there is a causal allele
(i.e.\ a particular nucleotide). Because we are reasoning
about the inheritance of alleles at a site on the genome
we can consider just the local tree at that site and
the network structure of the ARG is not important~\citep{wong2023general}.
In Fig.~\ref{fig:tree-illustration} we show the local tree
relating three diploid individuals for a given causal site.
Because these individuals are diploids, each is associated
with two nodes in the tree (highlighted by colour).
Ancestral nodes are not associated with individuals here,
but in general the ARG may be embedded in a multigenerational
pedigree, where some internal nodes would be associated
with individuals.

At a given site, the causal allele is associated with an
effect size $\beta$,
and every node in the tree that carries this allele has a
``genetic value'' of $\beta=0.05$. In the example of
Fig.~\ref{fig:tree-illustration}, T is chosen as the causal
allele, and therefore all nodes descending from \textsf{i}
have genetic value $0.05$, except \textsf{e} which
has zero because of the back-mutation to A.
Following the standard practise in GWAS~\citep{uffelmann2021}
we assume the additive model such that the overall
genetic value of an individual is the sum of its
nodes' genetic values.
Given these per-individual genetic values, the final phenotype
is then generated by adding some environmental noise.
This noise is normally distributed with mean zero
and variance of $V_G(1-h^2)/{h^2}$,
% TODO I find this clearer than saying "additive genetic variance"
where $V_G$ is the variance of the individual genetic values
and $h^2$ is the narrow-sense heritability provided as input by the user.
% The \texttt{tstrait} API is modular, however, and other forms of environmental
% noise can be easily generated by the user, if they wish.

\subsection{Interface}
\texttt{Tstrait} is a Python library, building on the \texttt{tskit}
ARG library~\citep{ralph2020,wong2023general} and the rich
Python data-science ecosystem~\citep{numpy}.
In the simplest case, simulating a phenotype for an ARG requires
very little code:
% NOTE this listing assumes num_causal has been moved, or removed.
% We need to check whether this actually works in the final version.
\begin{lstlisting}[language=Python]
import tstrait as tst
model = tst.trait_model('normal', mean=0, var=1)
result = tst.sim_phenotype(arg, model, h2=0.3)
\end{lstlisting}
We first create \texttt{model} representing the distribution
from which effect sizes are drawn. Five commonly used
univariate distributions are supported, along with the
multivariate normal distribution to model pleiotropic traits.
Given this model, we can then simulate phenotypes for the individuals
in an ARG (as a  \texttt{tskit TreeSequence}) using the
\texttt{sim\_phenotype} function, which also takes the trait model
and narrow sense heritability $h^2$ as parameters.
The return value \texttt{result} is an object encapsulating
two Pandas dataframes~\citep{pandas}: one describing the simulated
effect sizes and the other describing the genetic values,
environmental noise and final phenotypes for each individual.
The simulation results can then be efficiently and conventiently
processed by a host of Python data science tools.

This simple usage is not very flexible, however,
and so \texttt{tstrait} provides more modular building blocks
for power-users, and to potentially integrate with other tools.
Effect sizes can be simulated for a given ARG and trait model
using the \texttt{sim\_trait} function.
This function also supports a form
of frequency dependence, where the a simulated effect size
for a causal allele with frequency $p$
is multiplied by $\left(2p(1-p)\right)^\alpha$.
A negative value of $\alpha$
can be used to model the increased effect sizes on rare variants
resulting from negative selection~\citep{speed2017}.
The return value of the \texttt{sim\_trait} function is a
data frame describing the simulated effect sizes and causal alleles.
This dataframe can then be passed to the \texttt{genetic\_values}
function, which calculates the genetic values for each
node, and accumulates these per individual
(Fig~\ref{fig:tree-illustration}). Finally, the \texttt{sim\_env}
function takes these per-individual genetic values
and adds some simulated environmental noise to produce the final
phenotypes (as discussed above).

A major benefit of this modular approach to simulating effect sizes
and genetic values separately is the flexibility this offers
users. Because the causal sites and effect sizes are specified in a
simple tabular format, users can easily develop their own approach
to simulating these values. Alternatively, other simulators
such as SLiM~\citep{haller2023} that generate effect sizes and
causal mutations during the progress of a forwards-time simulation
(to model the effect of selection, for example) could output these
values to a CSV or similar file. The modularity here and simple
input data format is specifically intended to facilitate such
interoperability between simulators.

% \subsection{Phenotype}
% The final phenotype simulation is done in \texttt{tstrait}
% by imposing some environmental noise.
% We assume environmental noise is normally distributed with mean zero
% and a variance of
% \[
% V_G(1-h^2)/{h^2}
% \]
% where $V_G$ is the additive genetic variance from the simulated effect sizes,
% and $h^2$ is the narrow-sense heritability parameter provided as input.
% Thus, the \texttt{sim\_env} function takes the dataframe of genetic values
% and narrow-sense heritability as parameters:
% \begin{lstlisting}[language=Python]
% phenotype_df = tstrait.sim_env(
%     genetic_result.genetic, h2=0.3)
% \end{lstlisting}
% This simulation returns a dataframe
% describing the simulated genetic value, environmental noise and
% resulting phenotype for each individual at each causal site.

% As discussed above, there are significant advantages to providing a modular
% API. For convenience, we also provide a single
% \texttt{sim\_phenotype} function that combines the process of simulating
% effect sizes, generating genetic values and imposing environmental noise.

\subsection{Implementation and validation}
\texttt{Tstrait} is written entirely in Python. Many numerical operations are
peformed using standard array-oriented approaches and therefore
highly efficient~\citep{numpy}. Generating the genetic values for a given
trait is computationally intensive. This is done by a
straightforward tree traversal algorithm, which is
accelerated using the \texttt{numba} JIT compiler for Python yielding
excellent performance.

The \texttt{tstrait} codebase includes an extensive suite of unit tests,
which are automatically run as part of the development process. The
output of \texttt{tstrait} has been statistically validated against
[FILL ME IN].

\subsection{Performance}
\texttt{Tstrait} is very efficient, and can be applied to datasets at the
largest scales.
Supplementary Fig~\ref{fig:time}A shows how trait simulation time scales
with number of individuals, for sequences of length 50, 100 and 200Mb.
For each sample size and sequence length,
we first simulate an ARG under a simple coalescent model with
human-like parameters using~\texttt{stdpopsim}~\citep{adrion2020}.
We then run a quantitative trait simulation
with 1000 causal sites on this ARG using \texttt{tstrait},
and report the mean CPU time over 10 independent replicates.
For comparison, we also report the CPU time required by a
modified version of the code used by \citet{martin2017} for a
subset of these simulated ARGs.
A comparison with existing methods that require reading
in genetic sequences in formats such as
VCF~\citep[e.g.][]{meyer2018,fernandes2020} is not feasible,
as the VCFs involved are very large, and these tools assume that
the entire dataset fits in RAM.
Supplementary Fig~\ref{fig:time}B shows that RAM usage is very
modest for all these simulations.

Figure \ref{fig:time} (B) shows simulation time of \texttt{tstrait} with more
realistic data. For example, \texttt{tstrait} is used to simulate traits from
2.7 million individuals in the French Canadian dataset, which is the largest
known simulated genetic dataset \citep{anderson2023}. It took 60 seconds to
simulate a trait with 1000 causal sites, making \texttt{tstrait} to be
practical to simulate quantitative traits from this largest ever simulated
dataset. The inferred ARG from the 1000 Genomes project \citep{kelleher2019} is
also used to measure the computational performance.

\section{Conclusion}
We believe that in the coming years, simulation in tree sequence encoding will
attract more users in need of conducting genetic simulations with complex
population structure. Multiple studies highlight the advantages of using the
ARG data structure in GWAS \citep{link2023tree,nowbandegani2023extremely,zhang2023}.
ARG data
structure is becoming increasingly useful in genetic studies, as it is possible
to accurately infer biobank-scale genealogies from sequencing data
\citep{zhang2023}, and simulate large sample whole-genome sequences with
spatiotemporal metadata \citep{anderson2023}. These advances in ARG presents a
real opportunity for people to further understand the effects of complex
population structure on quantitative traits. The \texttt{tstrait} package is an
essential piece of infrastructure that lets people explore these possibilities.

\section{Competing interests}
No competing interest is declared.

\section{Acknowledgments}
We are grateful to Gregor Gorjanc, Ben Haller, Ben Jeffery and
others in the tskit community for helpful discussions and feedback.

\section{Funding}
DT is supported by the Oxford Kobe Scholarship from the University of Oxford
and the Euretta J. Kellett Fellowship from Columbia University.
JK acknowledges support from the Robertson Foundation,
NIH (research grants HG011395 and HG012473) and
EPSRC (research grant EP/X024881/1).


%USE THE BELOW OPTIONS IN CASE YOU NEED AUTHOR YEAR FORMAT.
\bibliographystyle{abbrvnat}
\bibliography{paper}

\clearpage

\renewcommand\thefigure{S\arabic{figure}}
\setcounter{figure}{0}
\renewcommand\thetable{S\arabic{table}}
\setcounter{table}{0}
\section{Supplementary Figures}

\begin{figure*}[t]%
\centering
% FIXME get the sizes right here and in the notebook where we're generating
% the figure so we don't have to scale here.
\includegraphics[width=213pt]{figures/time-scaling.pdf}
\caption{\textbf{Time taken to simulate quantitative traits.} Each point
represents the mean time for 10 independent runs under different random seeds.
The times reported are the total CPU time required to simulate quantitative
traits on an Intel(R) Core(TM) i9-11900H CPU and 16 GB of RAM. The trait model
is a normal distribution with $\mu=0$, $\sigma^2=1$, $h^2=0.3$, and
$\alpha=-1$. (A) CPU time with increasing number of individuals
based on ARGs simulated using \texttt{stdpopsim} with the [MODEL ID]
demographic mode. For each replicate we simulate
one quantitative trait with 1000 causal sites.
(B) CPU time with increasing number of causal sites on two large ARGs.
\texttt{tstrait} is used to simulate quantitative traits from
the simulated French Canadian dataset \citep{anderson2023} and the inferred
tree sequence dataset of the 1000 Genomes Project \citep{kelleher2019} with
varying number of causal sites. The French Canadian dataset is downloaded from
\url{https://zenodo.org/record/6839683}, and the inferred ARG from the 1000
Genomes Project is downloaded from \url{https://zenodo.org/record/3051855}.
Chromosome 9 is selected for both datasets.}\label{fig:time}
\end{figure*}

\end{document}
